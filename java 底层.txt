CAS
	一、什么是CAS
		简单说就是先比较再替换
		代码实例：
			AtomicInteger atomicInteger = new AtomicInteger();
			boolean flag = atomicInteger.compareAndSet(期望值, 修改值);
				期望值：表示工作内存从主物理内存拷贝出来的值
				修改值：希望将主物理内存修改成的值
				flag：如果期望值不等于当前主物理内存中的值将会修改主物理内存中的值失败并返回false
		CAS的全称Compare-And-Swap，它是一条CPU并发原语
		CAS的并发原语体现在JAVA语言中就是sun.misc.Unsafe类中的各个方法。调用Unsafe类中的CAS方法，JVM会帮我们实现出CAS汇编
		指令。由于CAS是一种系统原语，原语属于操作系统用语范畴，是由若干条指令组成的，用于完成某个功能的一个过程，并且原语
		的执行必须是连续的，在执行过程中不允许被中断，也就是说CAS是一个CPU的原子指令，不会造成数据不一致的问题(线程安全)
	二、CAS的底层原理
		1、自旋锁
		
		2、unsafe类
			是CAS的核心类，由于java方法无法直接访问底层系统，需要通过本地(native)方法来访问，Unsafe相当于一个后门，基于该类可以
			直接操作特定内存的数据，Unsafe类存在于sum.mic包中，其内部方法操作可以像C的指针一样直接操作内存，因此Java中CAS操作的
			执行依赖于Unsafe类的方法
			注意Unsafe类中的所有方法都是native修饰的，也就是说Unsafe类中的方法都直接调用操作系统底层资源执行相应任务。
			
			AtomicInteger 类的 getAndIncrement方法(相当于 i++)调用的 Unsafe 类的 getAndAddInt 方法
			Unsafe类的 getAndAddInt 方法原理
				public final int getAndAddInt(Object var1, long var2, int var4) {
						//var1:AtomicInteger类的当前对象 var2:当前对象的内存地址 var4:要增加的值
					int var5;
					do {
						var5 = this.getIntVolatile(var1, var2);
						//this.getIntVolatile(var1, var2):根据AtomicInteger类的当前对象和内存地址获取内存中的实际值
					} while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));
						//compareAndSwapInt(var1, var2, var5, var5 + var4):
						//	比较var5的值是否等于AtomicInteger类当前对象的内存地址中的实际值，等于的话加上var4的值，不等于的话
						//  将会再次根据AtomicInteger类的当前对象和内存地址获取内存中的实际值，循环往复，直到修改成功。
					return var5;
				}
	三、为什么用CAS不用synchronized
		synchronized 一次允许一个线程执行，并发性较差
	四、CAS的缺点
		1、Unsafe类的 getAndAddInt 方法有个 do while 循环，在不乐观的情况下会引发长时间循环的情况，会占用较多的CPU资源。
		2、只能保证一个共享变量的原子操作。
		3、引发ABA问题
			当两个执行时间有间隔的线程操作同一个共享变量时，一个线程已经将变量更改过N次并最后将变量的值更改为最初的值，当另一个
			线程想将更改的值赋给共享变量时，会比较期望值和实际值，发现两个值相等，最终还是可以成功将值赋给共享变量。但是这会丢失
			对于一个变量的一段时间的监控
			
			ABA问题的解决：
				使用带有标记的原子引用类 AtomicStampedReference ，这个类型的 compareAndSet 方法有四个参数，后两个参数是解决ABA
				问题的核心，它们分别是 【期望标记】 和 【更新标记】 ，当期望标记与实际标记不符时将不管期望值和实际值是否相等都
				会修改失败。


String 类
	在 main 方法中传递 String 变量到其他方法进行修改，然后在 main 方法中打印，发现值还是没有改变，原因是因为：
		在 java 中 String 变量每一次赋值都会重新生成一个 String 对象，内存地址会变动。

集合类				
	ArrayList
		ArrayList 是一个线程不安全的类，因为它在进行 add 的时候没有加 synchronized，底层数据结构是数组
	ArrayList 和 LinkedList 的 增删 和 查询 效率对比
		查询
			指定位置的查询 ArrayList 的效率要优于 LinkedList
				ArrayList 有下标可以直接定位到要查询的数据，LinkedList 没有下标只能通过循环数据用链表的指向关系来定位要查询的数据
		增删(在数据长度大于一的时候)
			在头部插值
				LinkedList 的效率要大于 ArrayList
					ArrayList 的插入操作需要进行全部数据的位移操作，而 LinkedList 只需要进行部分数据的指针更新操作
			在尾部加值
				当 ArrayList 到达需要扩容的界限时，ArrayList 的尾部加值操作效率会慢于 LinkedList
					ArrayList 的底层数组当需要存储的数据长度大于数组设置的长度时需要重新 new 一个合适长度的数组并进行全部数据的copy
					，而 LinkedList 的数据长度是自由的，不需要扩容的操作
				当 ArrayList 不需要扩容时，ArrayList 和 LinkedList 的尾部加值操作理论上效率是相差不多的
			在指定的位置(非头部和尾部)插值
				这里不能明确的说哪种更快，因为在指定的位置插值两者所消耗时间的点是不一样的，ArrayList 的点在于数据的位移，LinkedList
				在于数据的遍历定位，当 ArrayList 的数据位移所耗的时间要小于 LinkedList 的遍历定位所耗的时间时，ArrayList 的效率就高
				于 LinkedList，反之则 LinkedList 的效率更高。
				根据实际程序运行得出以下具体的结论：
					有一个长度都为n的数组、链表，当n长度小于一万时，当插入位置在0.2n之前 LinkedList 的遍历定位效率较高，当n的长度越
					大，达到百万级别时，只有当插入位置在0.1n之前时 LinkedList 的遍历定位效率才会较高
	HashMap
		以键值对存储的集合类，底层的数据结构是数组 + 链表。在jdk1.8 之后又引入了红黑树的数据结构：当 HashMap 的长度大于
		等于 8 的时候，将链表的数据结构转成红黑树。
	HashTable
		就是线程安全版的HashMap，将所有读写操作的方法都加上了 synchronized，故在多线程操作下效率较慢。
	HashMap 和 HashTable 的区别 
		HashTable 是线程安全的
		HashTable 不允许有 null 值的 key 和 value, HashMap 允许有 null 值的 key 和 value。
	HashSet
		底层是HashMap, 在 add 的时候将值放入 hashMap 的 key 中，value 是一个恒定的 new Object()
	LinkedHashMap
		它是 HashMap 的一个子类，它的数据结构也是数组 + 链表，不过它的链表是一个双向链表，每一个 Entry中同时记录了它的前
		一个值和后一个值，所以它可以根据插入的顺序循环显示出来数据。
	TreeMap
		底层数据结构是红黑树，根据 key 值进行排序
		
++i 和 i++ 的区别
	++i 先进行自增的操作随后将i的值压入操作栈中
	i++ 先将i的值压入操作栈中 随后进行自增
	= 操作符右边先算 左边后算
	
并发和并行的区别
	并发：多个线程抢一份资源
	并行：多个不相关的线程同时运行
	
并发编程的三个概念
	1、原子性
		一个或多个操作要么全部执行不允许中断，要么都不执行。
	2、可见性
		多个线程访问同一个变量时，一个线程修改了变量的值，其他的线程能够立即看到修改后的值。
	3、有序性
		程序的执行顺序按照代码的先后顺序执行。
		
java volatile 关键字
	当一个共享变量被 volatile 修饰后，它会保证修改的值会立即被更新到主物理内存，并对其他线程可见。但是这并不意味着volatile 
	关键字能够保证变量操作的原子性，例如多线程的自增操作每个自增都要经过三步(1、读取主物理内存，2、加1，3、写入主物理内存)
	，在2,3两步执行完成之前如果有其他线程进来，那么其他线程读取的还是旧的数据。
	
高内聚 低耦合是最好的程序设计模式：
	低耦合：
		程序各个功能模块之间应该尽量低耦合，两个模块之间的互通尽量使用数据交流，不使用具有控制意义的耦合，并且尽量不使用模
		块与模块之间的公共变量，如果必须使用也应该尽量缩小范围，这样一个模块的变动并不会或者比较小的影响其他的模块。
	高内聚：
		而模块的功能应该尽量独立，不依赖其他模块的代码。
	
Java 位运算符
	<<  左移运算符
		10 << 1 相当于 10 * 2 的 1 次方
	>>  右移运算符
		10 >> 1 相当于 10 / 2 的 1 次方
		
Java 取模 % 运算
	a % b = a - (a / b) * b
	注：b的值不可 0 
	
				
final 修饰符
	修饰变量
		类变量(被 static 修饰的变量)
			只能在 静态代码块 中或 声明类变量 时指定初始值。
		实例变量(未被 static 修饰的变量)
			只能在 非静态代码块 中，构造器中或声明实例变量时指定初始值。
		注：被 final 修饰的变量必须初始值之后才能使用，基本类型的变量不可以更改值，引用类型的变量不可以更改内存地址(例如 new)。
	修饰形参
		根据传入的参数完成初始化，不能被赋值更改。
	修饰引用类型变量
		保存的只是一个引用，只保证引用的地址不会改变，即一直引用一个对象，但是这个对象可以发生改变	
	修饰方法
		表示方法不可被重写，但是不影响重载。
	修饰类
		表示该类不可以有子类
		
REST 风格的请求方式
	URL定位资源(能够唯一地标识单个或一类资源)，用HTTP动词（GET,POST,DELETE,PUT）描述操作。
		
		
java 设计模式
	一、创建型模式
		1、简单工厂模式
			通过工厂类的方法可以根据不同的参数生成不同的继承自同一个父类的子类
		2、工厂模式
			多个工厂类实现同一个父级工厂接口的方法，方法内可以根据不同的参数生成不同的继承自同一个父类的子类
		3、抽象工厂模式
			同工厂模式一样也是多个工厂类实现同一个父级工厂接口的方法，不同的是子级工厂类里面的多个方法生成的多个不同对象是
			具有组合关系的，例如：同样实现 电脑 父级工厂接口的不同工厂类，一个里面生成的 cpu 主板都是 inter 的，一个里面
			生成的 cpu 主板都是 AMD 的
			

		
		
java 原理篇
	1、多线程


	2、jvm原理


	3、CG


	4、java 堆栈内存使用情况
	
	5、数据结构
		二叉树
			将第一个存储的数据作为树的根节点，比该根节点数值大的存入右边子节点，反之存入左边节点
			好处：
				大大提高搜索数据的效率，因为可以根据数值的比较选择左边还是右边的，不需要遍历全部数据
			缺点：
				当存入的数据是递增或者是递减的时候就会形成一个只有单边节点并且树的高度很高的二叉树，
				这样的话查询的效率和直接遍历全部数据是一样
		红黑树(平衡二叉树)
			在二叉树的基础上规定了数据树的高度差不能超过1，这样就避免了形成单边节点的数据树了
			缺点：
				1、当存储的数据量很多时，数据树的高度还是会很高，查找的深度很深的话查询效率就低了
				2、每一个io操作读取的数据量太小了，没有利用好磁盘IO的预读能力(空间局部性原理)，从而频繁的IO操作
		B-tree(B树) 多路平衡查找树
			B树是一个绝对平衡(所有的叶节点都在同一个高度上)的树
			一个节点可以有多个关键字，然后节点下可以有 关键字 + 1 个子节点，这样做的好处是：
				每次跟硬盘的IO操作可以在获取到的一页(4KB大小)数据中获取到更多的关键字和指针信息，充分利用了磁盘的预读能力
				，因为节点中存储的关键字变多，树的高度变低也就降低了IO操作的频次。
		B+tree
			B+树也是一个绝对平衡的树，与B树主要的不同点:
				1、B+树的关键字数量和子节点数量是一致的
				2、B+树的数据都存在叶节点上，而B树的数据分布在每一个节点，由于B+树的节点不保存的数据，这个就意味着每次的
				   IO操作，B+树可以从磁盘中读取更多的节点信息
				3、B+树的叶节点数据是有序的，并且有指向下一个叶节点最小数值的指针，这个有利于进行范围查询。
				
	6、算法
		1)、雪花算法
			是什么
				生成多服务全局唯一自增ID的一种算法
			为什么要用这个算法
				生成多服务全局唯一ID的方式及缺点
					UUID
						过长且无序，作为数据库主键不利于查询效率
					Mysql 的 replace into 加 自增主键ID
						每次执行会先删除然后进行插入，效率偏低且在数据库集群的环境下存在重复的问题
					redis集群
						怎么做到的
							通过设置步长(每次增加的数值，设置成redis服务器的数量)和不同的初始值，来达到不同redis服务器生成
							的ID绝不相同的目的
						弊端
							虽然满足了各种条件，但是为了一个ID搭建一套redis集群成本过高
			原理
				由 64 位 long 类型存储
				1、第 1 位
					固定为 0 
				2、2 ~ 41 (包含2) 之间 41 位
					存储时间戳
				3、42 ~ 52 (包含42) 之间 10 位
					自定义工作机器id，由5位的datacenterId和5位的worker组成，两者的取值范围都是0 ~ 31
				4、53 ~ 64 (包含53) 之间 12 位
					自定义序列号，用来记录同毫秒内产生的不同id，取值范围0~4094
	7、java 锁
		公平锁：
			按照先进先出的规则依次获取锁
		非公平锁：
			会首先尝试获取锁，如果没有获取到就采用公平锁的方式依次获取锁
		可重复锁(递归锁)
			指同一线程外层函数获得锁之后，在进入内层方法会自动获取锁，并且是用的同一把锁。
		自旋锁
			不堵塞线程，通过循环的方式获取锁，优点是减少了线程上下文的切换，确定是比较消耗cpu
		读写锁
			允许多个线程同时读取公共资源，但同一时间只允许一个线程进行写操作
			
java 框架篇
	1、spring 原理
		三大核心
			控制反转(IOC) 依赖注入(DI) 面向切面编程(AOP)
	2、redis
	
	3、Nginx
	
数据库
	Mysql高可用集群
		主从复制
		
		
高并发(多线程)编程
	List类
		使用 List<Object> list = new CopyOnWriteArrayList<>(); 解决 ConcurrentModificationException 报错
		原理：
			1、读取不加锁
			2、写入时加锁，写入时先复制一份经过扩容(length + 1)的副本，然后对副本进行操作，操作完之后将副本赋给原件，由于
			   数组变量是用 volatile 修饰的，其他引用该数组的线程会立刻发现数据的改变并从物理内存中获取最新的值。
			   注：为什么加锁了还是要先复制再操作，为了避免并发读写所引发的不可以预期的问题
	Set类
		使用 Set<String> set = new CopyOnWriteArraySet<>(); 解决 ConcurrentModificationException 报错
		CopyOnWriteArraySet 的 底层就是 CopyOnWriteArrayList, 原理和 CopyOnWriteArrayList 是一样的
	Map类
		使用 Map<String, String> map = new ConcurrentHashMap<>(); 解决 ConcurrentModificationException 报错
		原理：
			jdk1.8 之后主要使用 cas方式和 synchronized 锁来实现多线程同步操作，在 put 方法中通过 key 的 hashCode 计算出
			数组位置后，判断是否为 null，如果为 null 的话用 cas 的方式进行节点的添加，如果不为 null 并且 节点的 hash值
			不等于 MOVED (-1)(等于 MOVED 的话表示数组正在扩容) 的话就用 synchronized 锁的方式进行节点的添加。